// Якщо вже механізм this заплутаний навіть для досвідчених розробників, то перед тим, як перейти до того як він працює, ми повинні проаналізувати навіщо він потрібен. Розглянемо приклад:

// const me = {
//     name: 'Serg'
// };

// const you = {
//     name: 'Ivan'
// };

// function identify(context) {
//     return context.name.toUpperCase();
// }

// function speak(context) {
//     const greeting = `Hello, I'm ${identify(context)}`;
//     return greeting;
// }

// identify(you); // IVAN
// speak(me); // Hello, I'm SERG


// Чим складнішим буде паттерн, який ви використовуєте, тим ясніше ви будете бачити, що встановлення контексту явним параметром часто призводить до заплутанішого коду, ніж неявне зазначення контексту, використовуючи this. 




// Прив'язка this відбувається не під час час оголошення функції, а під час її виклику, тому значення this залежить від того, яким чином функція була викликана, та не має нічого спільного з визначенням функції

// Коли функція викликається, створюється так званий контекст виклику. Він містить інформацію про те:

// Звідки функція була викликана
// Як функція була викликана
// Які параметри були в неї передані, та ін.
// Однією з властивостей є посилання this, яке буде використовуватися протягом виконання цієї функції.




// Точка виклику функції та трейсинг

// оголошення функції baz()
// function baz() {
//     // стек викликів: `baz` тому наша точка виклику - глобальна область видимості

//     console.log('baz');
//     bar(); // <-- точка виклику для `bar`
// }

// // оголошення функції bar()
// function bar() {
//     // стек викликів: `baz` -> `bar` тому наша точка виклику в `baz`

//     console.log('bar');
//     foo(); // <-- точка виклику для `foo`
// }

// // оголошення функції foo()
// function foo() {
//     // стек викликів: `baz` -> `bar` -> `foo` тому наша точка виклику в `bar`

//     console.log('foo');
// }

// baz(); // <-- точка виклику для `baz`





// Прив’язка за замовчуванням
// Неявна прив’язка (об’єкт що володіє/ owner object)
// Явна прив’язка
// Прив'язка new



// Прив'язка за замовчуванням

// function foo() {
// 	console.log(this.a);
// 	console.log(this);
// }

// const a = 42;

// foo(); // 42




// Неявна прив'язка (об'єкт, що володіє / owner object)

// function foo() {
//     console.log(this.a);
// }

// const exampleA = {
//     a: 42,
//     foo,
// };

// const exampleB = {
//     a: 23,
//     exampleA,
// };

// exampleB.exampleA.foo(); // 42




// Явна прив'язка (call /apply)
// func.call(context, ...args);
// func.apply(context, args);


// Використовується якщо нам потрібно явно використовувати при виклику функції
//  вказаний об'єкт для прив'язки this, без поміщення посилання на метод в об'єкт.

// function foo() {
//     console.log(this.a);
// }

// const example = {
//     a: 42,
// };

// foo.call(example); // 42



// Прив'язка new
// Створюється новий об'єкт (тобто конструюється) прямо з «повітря»
// Щойно сконструйований об'єкт зв'язується з [[Prototype]]
// цей об'єкт встановлюється як this для цього виклику функції
// За винятком тих випадків, коли функція повертає свій власний альтернативний об'єкт, виклик функції з new автоматично поверне щойно сконструйований об'єкт

// function foo(a) {
//     // this = {} – неявне створення об’єкту

//     // додаємо властивості до this
//     this.a = a;

//     //return this – не явне повернення об’єкту який в себе включає властивість- «а»
// }

// const baz = new foo(42);
// console.log(baz.a); // 42







// Визначаємо this
// Тепер можна коротко сформулювати правила для визначення this за точкою виклику функції, у порядку їхнього пріоритету.

// Функція викликана з оператором new (прив'язка new) Раз так, то this — новий сконструйований об'єкт.
// Функція викликана з call / apply (явна прив'язка) або bind (жорсткої прив'язки)? Тоді this — явно вказаний об'єкт
// Функція викликана, як така, що належить об'єкту (неявна прив'язка), інакше званим як об'єкт, що володіє або містить? Якщо так, то this є тим самим об'єктом, що володіє.
// В іншому випадку, буде this за замовчуванням (прив'язка за замовчуванням). У режимі strict mode, це буде undefined, інакше буде об'єкт global.








// let worker = {
//     someMethod() {
//         return 1;
//     },

//     slow(x) {
//         // alert("Викликана з " + x);
//         return x * this.someMethod(); // (*)
//     }
// };

// function cachingDecorator(func) {
//     let cache = new Map();
//     return function (x) {
//         if (cache.has(x)) {
//             return cache.get(x);
//         }

//         console.log('this > ', this);
//         // let result = func.call(this, x); // "this" зараз передано правильно
//         let result = func(x);
//         cache.set(x, result);
//         return result;
//     };
// }

// worker.slow = cachingDecorator(worker.slow); // тепер зробимо цьому методу кешування

// alert(worker.slow(2)); // працює
// alert(worker.slow(2));
